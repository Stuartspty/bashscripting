2. Variáveis e Parâmetros
   **********************

   Ao contrário das outras linguagens, o bash não possui "tipos de dados",
todas as variáveis são strings. O bash usa strings para representar todos
os dados que serão usados pelas variáveis. A seguir falaremos sobre os
*tipos de variáveis* (e não "tipos de dados").
   Se você conhece alguma outra linguagem de programação sabe que os
identificadores possuem algumas regras quanto a sua nomeclatura. Pois no
bash as regras são parecidíssimas:

   * Só se pode usar caracteres alfanuméricos e underline;
   * Só se pode começar com letra ou underline (número não pode);
   * Não pode conter espaços em branco;
   E uma coisa que nós, falantes da língua portuguesa temos que saber é:
   * Os identificadores NÃO podem conter acentos!

   enfim... todas aquelas regrinhas para identificadores de linguagens de
programação também se aplica aqui, exceto aquela famosa sobre palavras
reservadas. Você pode por exemplo fazer "if=lalala" que funcionará
perfeitamente. A única coisa que não pode é usar um nome que já tenha sido
definido para uma outra variável e que esta seja "readonly" (mais sobre
isso adiante). Também deve-se tomar cuidado para não fazer bobagens com
as variáveis do shell (explicados no tópico 2.2.).



2.1.  Variáveis do Usuário
      ====================

   As variáveis do usuário são as variáveis que você pode declarar, ler,
inicializar e modificar. No exemplo abaixo nós criamos uma variável
chamada "nome" e atribuímos a ela o valor "Meleu". Veja:

     $ nome=Meleu

   Não pode haver espaços nem antes nem depois do sinal de '='! Se você
quiser atribuir um valor que contenha espaços é necessário usar as
'aspas simples'.
Veja:

     $ nome='Meleu nao eh meleca!'

   Agora para usar a variável é só você colocar um cifrão '$' antes do
nome dela. Olhe um exemplo com e sem o '$':

     $ echo nome
     nome
     $ echo $nome
     Meleu não eh meleca!

   Existe diferença entre usar 'aspas simples', "aspas duplas", `crases` e
não usar nada.
Veja isto:

/* -=-=-=-=-= exemplos =-=-=-=-=- */
$ caminho='O meu path eh: $PATH'
$ echo $caminho
O meu path eh: $PATH

$ caminho="O meu path eh: $PATH"
$ echo $caminho
O meu path eh: /usr/local/bin:/usr/bin:/bin:/usr/X11R6/bin:/usr/openwin/bin

$ teste=`ls $HOME`
$ echo $teste
GNUstep/ progs/ textos/

$ conteudo_dir="Meu diretorio home contem: `ls $HOME`"
$ echo $conteudo_dir
Meu diretorio home contem: GNUstep/ progs/ textos/

$ teste=isso nao eh valido
bash: nao: command not found

$ teste=mas_isso_eh_valido
$ echo $teste
mas_isso_eh_valido

/* -=-=-=-=-= exemplos =-=-=-=-=- */

   Os mais espertos já perceberam as diferenças... mas para os mais
lerdinhos (como eu) aí vai uma explicação.

+ 'aspas simples': atribuem à variável EXATAMENTE o que está entre elas;

+ `crases`: atribuem à variável a *saída do comando* que está entre elas,
            tem a capacidade de ver o conteúdo de uma variável
            (no exemplo acima, a variável de ambiente $HOME);

+ "aspas duplas": atribuem à variável a string, o valor das variáveis que
                  porventura podem estar entre elas (no segundo exemplo, a
                  variável de ambiente $PATH), e também a saída de comandos
                  que estejam entre `crases`;

+ nada: similar as aspas duplas, porém ignora espaços excedentes.

   Podemos usar $(cifrão-parênteses) no lugar das crases. Em alguns casos
é melhor usar $(cifrão-parênteses) mas eu não vou falar em quais, você
vai descobrir quando. ;-)
Veja estes exemplo:

/* -=-=-= exemplo =-=-=- */
$ dir_atual=$(pwd)
$ echo $dir_atual
/home/meleu

$ echo $(ls $HOME)
GNUstep/ progs/ textos/

$ tar czvf backup_$(date +%d-%m-%Y).tgz arquivo
/* -=-=-= exemplo =-=-=- */

   Outra coisa interessante é o uso das {chaves}. Você pode usar as chaves
para exibir uma variável (ex.: echo ${teste}), isso é útil quando você
precisa separar a variável do que vem depois dela. Veja isto:

/* -=-=-=-=-= exemplo =-=-=-=-=- */
$ name=coracao
$ echo ${name}deleao
coracaodeleao
/* -=-=-=-=-= exemplo =-=-=-=-=- */


   Como eu disse anteriormente, quando executamos um shell script ele usa
outro shell, portanto toda variável que for criada/inicializada num shell
script perderá seu valor no final da execução do mesmo. No entanto, você
pode fazer um shell script usar variáveis de usuário exportando-a
com o comando "export" (ver man page do bash). Um exemplo simples:

/* -=-=-=-=-= exemplo =-=-=-=-=- */
$ cat teste.sh
#!/bin/bash

echo "$VAR"

$ export VAR='Um abraco para os gajos de Portugal! :)'
$ ./teste.sh
Um abraco para os gajos de Portugal! :)
$ export VAR='--> mudei a variavel <--'
$ ./teste.sh
--> mudei a variavel <--
/* -=-=-=-=-= exemplo =-=-=-=-=- */



2.1.1. Variáveis Array
       ---------------

   Também conhecidas como vetores. Este tipo de variável serve para se
armazenar vários valores sob um nome e um índice. A maneira de declarar
variáveis array é a seguinte:

NomeDaVariavel[Indice]=Valor

sendo que Indice deve ser necessariamente um valor inteiro.

   Imaginemos que EvilLord queira armazenar uma lista de suas frutas
favoritas em uma variável array. Para isso ele faria o seguinte:

/* -=-=-= exemplo =-=-=- */
$ FRUTA[0]=goiaba
$ FRUTA[1]=manga
$ FRUTA[2]=pera
$ FRUTA[3]=laranja
/* -=-=-= exemplo =-=-=- */

   Supondo que ele colocou esta lista em ordem decrescente de gosto, para
sabermos qual é a sua fruta favorita basta digitarmos:

$ echo ${FRUTA[0]}

   Bacana não acham?

   Agora vejamos uma coisa interessante. Se eu declarar uma frut... ops!
digo, se eu declarar uma variável assim:

$ FRUTA=goiaba

e depois quiser fazer um array com o nome FRUTA eu posso fazer assim:

$ FRUTA[1]=manga

Desta maneira 'goiaba' passa a ser armazenada em FRUTA[0]   

   Outra coisa interessante é que podemos declarar um array inteiro numa
única linha de comando. Para isto usamos a sintaxe:

NomeDoArray=(valor1 valor2 ... valorn)

Desta maneira o EvilLord economizaria teclado (?!) digitando isto:

$ FRUTA=(goiaba manga pera laranja)

E para vermos toda a lista de uma vez só, podemos usar o seguinte comando:

$ echo ${FRUTA[*]}


   Existem várias outras especificações para arrays mas quero passar aqui
só o básico. E se você precisar usar arrays de maneira mais complexa que
isso: vá procurar a documentação oficial do bash! :P



2.2.  Variáveis do Shell
      ==================

   Existem variáveis que o shell usa constantemente para um melhor
funcionamento. O próprio shell inicializa algumas destas variáveis, que
podem ser lidas e alteradas pelo usuário, estas são conhecidas como
variáveis do shell. Servem para determinar qual é o seu diretório home, em
qual diretório o shell vai procurar por comandos que você digitar, seu
prompt...  enfim... um bocado de coisas. Você pode atribuir novos valores
para estas variáveis (uma boa é fazer isso no seu ~/.bashrc ou
~/.bash_profile).

   Vamos ver algumas destas variáveis mais importantes e suas respectivas
funções.


--> HOME

   Esta variável tem um nome bem descritivo não acham? Bem... como nós já
sabemos, o nosso diretório home é o diretório em que "caímos" assim que
nos logamos (sabemos também que esta informação se encontra em
/etc/passwd). Quando você se loga no sistema o bash pega o nome do
diretório que você está e o atribui à variável HOME.
   Você já deve ter percebido que quando você dá um "cd" sem nenhum
argumento você vai para o seu diretório home. Pois o que o cd faz é o
mesmo que "cd $HOME". Se você alterar o valor de HOME, quando você
digitar cd sem nenhum argumento o bash vai tentar te levar para o $HOME.
Veja:

/* -=-=-=-=-= exemplo =-=-=-=-=- */
meleu:/usr/doc$ echo $HOME
/home/meleu
meleu:/usr/doc$ cd
meleu:~$ pwd
/home/meleu
meleu:~$ HOME=/tmp
meleu:/home/meleu$ cd
meleu:~$ pwd
/tmp
meleu:~$ HOME=lalala
meleu:/tmp$ cd
bash: cd: lalala: No such file or directory
/* -=-=-=-=-= exemplo =-=-=-=-=- */

   Você também já deve ter reparado que quando estamos no nosso home
aparece um til (~) logo antes do prompt. Observe este detalhe no exemplo
acima. ;) 


--> PATH

   Esta variável armazena o caminho (path) que o shell irá percorrer para
procurar um comando digitado pelo usuário. Exemplo:

/* -=-=-= exemplo =-=-=- */
meleu@meleu:/tmp$ echo $PATH
/usr/local/bin:/usr/bin:/bin:/usr/X11R6/bin:/usr/games:/usr/share/texmf/bin
/* -=-=-= exemplo =-=-=- */

Portanto se eu digitar um "ls" o shell irá procurar pelo "ls" em
/usr/local/bin depois em /usr/bin e daí em diante.
   Esta variável algumas vezes pode ser usada no hacking! Imagine que
um programador inexperiente tenha feito um programa suid que usa a função
system() (ou qualquer outra função que sirva para executar um comando
externo), e nesta função ele não usa o caminho completo do programa, e
sim apenas o nome do programa, supondo que o programa está no seu PATH
normal. Você pode alterar o PATH e executar um outro programa de sua
preferência.
   Vamos supor que o cara use:

   system ("date");

   no lugar de:

   system("/bin/date");

   Aí você faz um programa ou um shell script e nomeia ele como "date".
Agora é só alterar o PATH para que procure primeiro no diretório onde
você salvou o SEU date, e então executar o programa suid feito pelo
incompetente programador. Faça uns testes aí que você vai me
entender melhor.
   Esta situação é bem difícil de se encontrar hoje em dia, resolvi
colocar aqui por questões históricas. :P


--> PS1

   Esta é a "Prompt String 1" ou "Primary Prompt String". Nada mais é do
que o prompt que nos mostra que o shell está esperando um comando. Quando
você muda PS1 você muda a aparencia do prompt. Na minha máquina o padrão é
'\u@\h:\w\$ ' onde \u significa o nome do usuario, \h significa o nome do
host e \w é o diretório atual, o que dá a seguinte aparência:

meleu@meleu:/usr/doc/Linux-HOWTOs$

   Veja algumas possibilidades (na man page do bash tem mais):

              \d    mostra a data atual
              \h    mostra o hostname
              \s    o nome do shell
              \t    a hora atual (no estilo 24 horas)
              \T    a hora atual (no estilo 12 horas)
              \u    nome do usuário que está usando o shell
              \w    nome do diretório atual (caminho todo)
              \W    nome do diretório atual (somente o nome do diretório)

   Se você estiver afim de ter a impressão de que está no shell do root
basta trocar o '$' por '#' (bah! que bobagem! :P ).
   Para aprender a fazer um monte de gracinhas com o PS1 dê uma lida no
Bash-Prompt-HOWTO (ver 10. Referências)


--> PS2

   Esta é a "Secondary Prompt String". É usada quando um comando usa mais
de uma linha. Por exemplo:

/* -=-=-= exemplo =-=-=- */
$ echo m\
> e\
> l\
> e\
> u
meleu
$ echo 'm
> e
> l
> e
> u'
m
e
l
e
u
/* -=-=-= exemplo =-=-=- */

   Este sinal '> ' (maior-espaço) é o PS2. Você pode usar os mesmos
caracteres especiais que o PS1 usa.


--> MAIL

   Nada mais é do que o arquivo onde são guardados seus emails. Aqui na
minha máquina eu uso o sendmail como servidor de email, portanto:

/* -=-=-= MAIL =-=-=- */
meleu@meleu:~$ echo $MAIL
/var/spool/mail/meleu
/* -=-=-= MAIL =-=-=- */

porém se estivesse usando qmail seria:

/* -=-=-= MAIL =-=-=- */
meleu@meleu:~$ echo $MAIL
/home/meleu/Mailbox
/* -=-=-= MAIL =-=-=- */


--> SHLVL

   Esta variável armazena quantos shells você executou a partir da
primeira shell.
   Confuso? Vamos a um exemplo.
   Imagine que você está usando o bash e executou o bash de novo, nesta
situação o seu SHLVL vale 2. Veja isto:

/* -=-=-= exemplo =-=-=- */
$ echo $SHLVL
1
$ bash		# estou executando o bash a partir do bash
$ echo $SHLVL
2
$ exit		# saí do segundo bash
exit
$ echo $SHLVL
1
/* -=-=-= exemplo =-=-=- */

   Quando você inicializa scripts a partir do comando "source" o script é
executado no shell pai, portanto se tiver um "exit" no script você vai
executar um logoff. É aí que está a utilidade da variável SHLVL. Quando
você está no shell primário o valor de SHLVL é 1. Então você pode, através
de um "if" por exemplo, executar o "exit" só se SHLVL for diferente de 1
(mais informações sobre o source em "6.1 Funções como comandos").



--> PROMPT_COMMAND

   Esta é bem interessante. Ela armazena um comando que será executado
toda hora que o prompt é exibido. Veja:

/* -=-=-= exemplo =-=-=- */
$ PROMPT_COMMAND="date +%T"
19:24:13
$ cd
19:24:17
$ ls
GNUstep/  bons.txt  pratica/  teste  worldwritable.txt
Mail/     hacking/  progs/    txts/
19:24:19
$
19:24:32
$  # isso eh uma linha sem nenhum comando
19:24:49
$
/* -=-=-= exemplo =-=-=- */

   Esta variável é útil quando queremos brincar com o prompt, para
aprender mais sobre isso leia o Bash-Prompt-HOWTO (v. 10. Referências).


--> IFS

   O shell usa esta variável para dividir uma string em palavras
separadas. Normalmente o IFS é um espaço, uma tabulação (Tab) e um
caractere nova linha (\n). Desta maneira:

isto eh uma string

são quatro palavras, pois IFS é um espaço e as palavras estão separadas
por espaço. Agora se eu mudar IFS para um ':' desta maneira:

IFS=':'

então a string:

isto:eh:uma:string

conterá quatro palavras. Isto é útil para casos como neste exemplo:

/* ----------------- */
<++> BashScript/path.sh
#!/bin/bash

IFS=':'

for item in $PATH ; do
	echo $item
done

<-->
/* ----------------- */

   Se IFS for uma variável nula (vazia), tudo será considerado uma única
palavra. Por exemplo:

se o IFS for nulo, toda essa linha será considerada uma única palavra	



--> RANDOM

   Quando você exibe esta variável ("echo $RANDOM") é exibido um número
aleatório entre 0 e 32767.
   Pra que serve isso?
   Sei lá! Várias coisas. Quem é criativo sempre precisa de um número
aleatório... Imagine que você queira um número de telefone celular
qualquer (sei lá pra quê!), você pode fazer um script que gera um número
desse pra você. Aqui na minha região estes números começam com 99 ou 98,
e têm um total de 8 dígitos. O script a seguir gera números que comecem
com 98 somente:

/* ----------------- */
<++> BashScript/cellnumbergen.sh
#!/bin/bash

NUM="98$(echo $RANDOM)0"
CONT=$(echo -n $NUM | wc -c)	# quantos digitos tem?

while [ $CONT -lt 8 ]; do	# se nao tiver 8 digitos acrescenta 0's
	NUM=${NUM}0
	CONT=$(echo -n $NUM | wc -c)
done

echo $NUM
<-->
/* ----------------- */


--> Outras

   Outras variáveis que são muito usadas:
   MAILCHECK ; HISTFILE ; HOSTNAME ; LS_OPTIONS ; LS_COLOR ; MANPATH ;
   SHELL ; TERM ; USER ; PS3 .

   Estas são as mais utilizadas, porém existem muitas outras. Para ver
quais são as variáveis definidas no momento basta entrar com o comando
"set". E para ver apenas as variáveis de ambiente use "env".
   Olhe a man page do bash na seção "Shell Variables" para mais detalhes.



2.3. Variáveis Somente-Leitura
     =========================

   Como sabemos as variáveis podem ter seu valor modificado pelo usuário,
mas se nós quisermos variáveis que NÃO possam ter seus valores alterados
basta declararmos tal variável como somente-leitura. Para tornar uma
variável read-only podemos usar o comando "readonly" ou então
"declare -r".
 Veja os exemplos a seguir, ambos possuem o mesmo resultado:

/* -=-=-=-=-= exemplo-1 =-=-=-=-=- */
$ readonly NOME="Meleu Zord"
$ echo $NOME
Meleu Zord
/* -=-=-=-=-= exemplo-1 =-=-=-=-=- */

/* -=-=-=-=-= exemplo-2 =-=-=-=-=- */
$ declare -r NOME="Meleu Zord"
$ echo $NOME
Meleu Zord
/* -=-=-=-=-= exemplo-2 =-=-=-=-=- */

   Agora só pra ter certeza:

/* -=-=-= teste =-=-=- */
$ NOME=Fulano
bash: NOME: readonly variable
$ echo $NOME
Meleu Zord
/* -=-=-= teste =-=-=- */

   Um bom uso deste tipo de variável é para garantir que variáveis
importantes de um determinado script não possam ser sobregravadas,
evitando assim algum resultado crítico.

   O comando "readonly" quando usado sem parâmetros (ou o comando "declare"
apenas com o parâmetro "-r") nos mostra todas as variáveis declaradas como
somente-leitura. No exemplo a seguir se for usado "declare -r" no lugar de
"readonly" teríamos a mesma saída.

/* -=-=-=-=-= readonly =-=-=-=-=- */
$ readonly
declare -ar BASH_VERSINFO='([0]="2" [1]="05" [2]="0" [3]="1" [4]="release"
[5]="i386-slackware-linux-gnu")'
declare -ir EUID="1005"
declare -ir PPID="1"
declare -r
SHELLOPTS="braceexpand:hashall:histexpand:monitor:ignoreeof:interactive-comments:emacs"
declare -ir UID="1005"
/* -=-=-=-=-= readonly =-=-=-=-=- */

   Existem várias variáveis somente-leitura que são inicializadas pelo
shell, como USER, UID.

   TODAS as variáveis readonly uma vez declaradas não podem ser "unsetadas"
ou ter seus valores modificado. O único meio de apagar as variáveis
readonly declaradas pelo usuário é saindo do shell (logout).



2.4. Parâmetros
     ==========

   Podemos passar parâmetros para o shell script assim como na maioria
dos programas. Os parâmetros são variáveis, digamos, especiais. Para
começar elas não obedecem as regras de nomeclatura de variáveis, pois
elas usam números; e também nós não podemos mudar o valor destas
variáveis pelas vias "tradicionais", para mudar o valor destas nós temos
que contar com a ajuda do shift e/ou do set (como veremos adiante).

Veja esta relação:

     $0                  é o nome do shell script (a.k.a. parâmetro zero);

     $1 a $9             $1 é o primeiro parâmetro, $9 o nono, e
                         assim por diante;

     ${10}, ${11}...     quando o número do parâmetro possui mais de um
                         dígito é necessário o uso das chaves;

     $*                  todos os parâmetros em uma única string
                         (exceto o $0);

     $@                  todos os parâmetros, cada um em strings
                         separadas (exceto $0);

     $#                  número de parâmetros (sem contar com o $0).

                  Outros:

     $?                  valor de retorno do último comando
                         (explicado mais adiante);

     $$                  PID do script.

   Pra ficar mais claro, nada melhor do que um exemplo:

/* ------------------ */
<++> BashScript/parametros.sh
#!/bin/bash
#
# "basename" serve para eliminar o caminho do arquivo e mostrar
# somente o último nome dele. Neste caso: parametros.sh
echo "Nome do script: `basename $0`"
echo "Número total de parâmetros: $#"
echo "Primeiro parâmetro: $1"
echo "Segundo parâmetro: $2"
echo "Décimo quinto parâmetro: ${15}"
echo "Todos os parâmetros: $*"
<-->
/* ------------------ */

/* -=-=-=-=-= exemplo =-=-=-=-=- */
$ ./parametros.sh a b c d e f g h i j l m n o p q r s t u v x z
Nome do script: parametros.sh
Número total de parâmetros: 23
Primeiro parâmetro: a
Segundo parâmetro: b
Décimo quinto parâmetro: p
Todos os parâmetros: a b c d e f g h i j l m n o p q r s t u v x z
/* -=-=-=-=-= exemplo =-=-=-=-=- */


   Se você não entendeu direito a diferença entre o $* e o $@, então dê
uma olhada no seguinte script (se não entendê-lo tudo bem, siga em frente
e quando aprender sobre o "if" e o "for" leia-o novamente):

/* ------------------ */
<++> BashScript/testargs.sh
#!/bin/bash
# Ao executar este script entre alguns parametros. Ex.:
# [prompt]$ ./testargs.sh um dois tres quatro

if [ -z "$1" ]; then
  echo "Uso: `basename $0` argumento1 argumento2 etc."
  exit 1
fi

echo
echo "Listando argumentos com \"\$*\":"
num=1
for arg in "$*"; do
  echo "Arg #$num = $arg"
  num=$[ $num + 1 ]
done
# Conclusão: $* mostra todos os argumentos como uma única string

echo
echo "Listando argumentos com \"\$@\":"
num=1
for arg in "$@"; do
  echo "Arg #$num = $arg"
  num=$[ $num + 1 ]
done
# Conclusão: $@ mostra cada argumento em strings separadas

echo
<-->
/* ------------------ */



2.4.1. shift
       -----

   O bash possui um comando embutido que lida com parâmetros, o shift.
Quando você usa o shift sai o primeiro parâmetro da lista e o segundo vai
para $1 o terceiro vai para $2, e assim por diante. Você pode ainda
especificar quantas "casas" você quer que os parâmetros "andem" à
esquerda através de "shift n" onde 'n' é o número de casas, mas se o
número de casas que ele deve andar for maior que o número de parâmetros
o shift não é executado.
Veja este exemplo:

/* ------------------ */
<++> BashScript/shift-exemplo.sh
#!/bin/bash
echo "$#: $*"
echo -e "executando \"shift\""
shift
echo "$#: $*"
echo -e "executando \"shift 5\""
shift 5
echo "$#: $*"
echo -e "executando \"shift 7\""
shift 7
echo "$#: $*"
<-->
/* ----------------- */

/* -=-=-=-=-= shift =-=-=-=-=- */
$ ./shift-exemplo.sh 1 2 3 4 5 6 7 8 9 0
10: 1 2 3 4 5 6 7 8 9 0
executando "shift"
9: 2 3 4 5 6 7 8 9 0
executando "shift 5"
4: 7 8 9 0
executando "shift 7"
4: 7 8 9 0
/* -=-=-=-=-= shift =-=-=-=-=- */

   Os valores que saem são perdidos. Use com atenção!



2.4.2. set (para editar parâmetros)
       ----------------------------

   O que vou passar neste tópico não é sobre como usar "todo o poder do
comando set", e sim como usar set especificamente para editar parâmetros.
Não tem nenhum segredo! Veja este exemplo:

set um dois tres

   Isso fará com que $1 seja 'um', $2 seja 'dois', $3 seja 'tres' e só!
Não existirá $4, $5, etc. mesmo que eles tenham sido usados. Veja um
exemplo de script:

/* ----------------- */
<++> BashScript/setparam.sh
#!/bin/bash

echo "Os $# parâmetros passados inicialmente foram: $@"
echo
echo "e agora eu vou alterá-los!"
echo "como eu sou mau... (huahuahau risada diabólica huahuahuha)"
echo
set um dois tres
echo "Os $# novos parâmetros agora são: $@"
echo
<-->
/* ----------------- */

   Não interessa quantos parâmetros você passar para este script, no
final você só terá $1, $2 e $3 valendo 'um', 'dois' e 'tres',
respectivamente.

   No meu Mextract.sh (tópico 9.5.) esta característica do set é muito
bem aproveitada! ;-)



2.5. Substituição de Variáveis
     =========================

   Isto é muito útil e pode ser muito mais elegante que ficar usando if's
(explicados mais adiante) sem necessidade! Veja que bacana! ;-)


--> ${variavel:-string}

   Se "variavel" não tiver sido definida ou for vazia será substituída por
"string". O valor da variável não é alterado. Veja este exemplo:

/* -=-=-= exemplo =-=-=- */
$ echo ${URL:-"http://unsekurity.virtualave.net"}
http://unsekurity.virtualave.net
$ echo $URL # observe que URL nao foi alterado

/* -=-=-= exemplo =-=-=- */


--> ${variavel:=string}

   Se "variavel" não estiver sido definida ou for vazia, receberá
"string". Exemplo:

/* -=-=-= exemplo =-=-=- */
$ echo ${WWW:="http://meleu.da.ru"}
http://meleu.da.ru
$ echo $WWW
http://meleu.da.ru
/* -=-=-= exemplo =-=-=- */


--> ${variavel:?string}

   Se "variavel" não estiver sido definido ou for vazia, "string" será
escrito em stderr (saída de erro padrão). O valor da variável não é
alterado. Veja um exemplo:

/* -=-=-= exemplo =-=-=- */
$ echo ${EDITOR:?"Nenhum editor de texto"}
bash: EDITOR: Nenhum editor de texto
$ echo $EDITOR

/* -=-=-= exemplo =-=-=- */


--> ${variavel:+string}

   Se "variavel" estiver definida, será substituída por "string" mas seu
valor não será alterado. Exemplo:

/* -=-=-= exemplo =-=-=- */
$ echo ${BROWSER:+"BROWSER definido como \"$BROWSER\""}
BROWSER definido como "links"
/* -=-=-= exemplo =-=-=- */

