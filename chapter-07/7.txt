
7. Tornando seu script amigável
   ****************************

   Alguns comandos úteis que tornam seu script mais "user-friendly".


7.1. getopts
     =======

   Este comando serve para permitir que você use parâmetros na linha de
comando de maneira mais eficiente que ficar usando as variáveis de posição
de parâmetros ("$1", "$2"...). 
   Sua sintaxe é:

getopts 'CadeiaDeOpcoes' variavel

Onde "CadeiaDeOpcoes" consiste em cada caractere que o getopts
considerará, e "variavel" receberá este caractere. Para passar um
parâmetro para o script você usa '-c' onde 'c' é o parâmetro. Veja este
exemplo hipotético:

getopts 'ab:c' variavel

   Você poderá usar os parâmetros 'a', 'b' ou 'c'. Note que 'b' é seguido
de um ':', isso significa que 'b' é um parâmetro que precisa de
argumento. Este, por sua vez, é armazenado na variável OPTARG.

   Mais detalhadamente, o getopts funciona assim (adaptado do "Teach
Yourself Shell Programming in 24 Hours", veja Referências):

    1. O getopts examina todos os argumentos da linha de comando
       procurando por argumentos que comecem com o caractere '-'.

    2. Quando acha um argumento começado com '-' o getopts procura
       em "CadeiaDeOpcoes" se tem algum caractere que combine.

    3. Se combinar com algum, "variavel" receberá este caractere,
       caso contrário "variavel" receberá '?'.

    4. Os passos 1-3 são repetidos até que todos os argumentos da
       linha de comando tenham sido lidos.

    5. Quando acaba de ler todos os argumentos da linha de comando
       getops retorna um valor falso (não-zero). Isto é útil para
       verificações em loops (como veremos no exemplo abaixo).


   Hmmm... Confuso? Numa primeira olhada é confuso mesmo, é muita
informação de uma vez só. Portanto dê uma olhada no exemplo a seguir,
execute-o e depois releia este tópico. Não se esqueça de fazer o mais
importante: praticar!


/* ----------------- */
<++> BashScript/getopts.sh
#!/bin/bash

USAGE="Uso: `basename $0` [-h] [-n nome] [-e email]"

[ $1 ] || { echo $USAGE ; exit 1 ; }

# observe que 'n' e 'e' precisam de argumentos
while getopts 'hn:e:' PARAMETRO; do

# atente para a utilidade do "case"! ;-)
    case $PARAMETRO in

	h) echo -n "
Script de exemplo de uso do \"getopts\".

Uso: `basename $0` [opções]

Onde as opções podem ser:

-n nome         imprime nome
-e email        imprime email
-h              exibe esta mensagem" ;;

	n) NOME=$OPTARG ;;

	e) EMAIL=$OPTARG ;;

	*) echo -n "Entre \"`basename $0` -h\" para ajuda." ;;
    esac
done

[ $NOME ] && echo $NOME
[ $EMAIL ] && echo $EMAIL
<-->
/* ----------------- */

   Execute este código e tire suas próprias conclusões.

   Você pode ver mais um script que usa getopts no tópico "Exemplos
Variados".



7.2. select
     ======

   Este comando serve para fazer menus, onde o usuário pode escolher uma
dentre várias opções. 
   Sua sintaxe é um pouco parecida com a do "for":

select opcao in lista-de-opcoes

   A diferença é que o for faz um loop para cada palavra que estiver na
"lista-de-opcoes" enquanto o select espera que o usuário escolha uma
opção dentre as que estão na lista.

   Veja este exemplo:

/* ----------------- */
<++> BashScript/conta.sh
#!/bin/bash

function Mecho {
        echo -e "\e[1m$*\e[m"
}

# ATENÇÃO AQUI: o prompt que o select mostra é controlado pela
#               variável PS3. E todas aqueles comentários sobre
#               o PS1 feitas no tópico 2.2. valem aqui também.
PS3="Opção: "

echo -n "Entre com o primeiro número: "
read NUM1
echo -n "Entre com o segundo número: "
read NUM2

OPCOES="adicao subtracao multiplicacao divisao sair"

select opc in $OPCOES; do
    if [ "$opc" = adicao ]; then
	Mecho "$NUM1 + $NUM2 = $[ $NUM1 + $NUM2 ]"
    elif [ "$opc" = subtracao ]; then
	Mecho "$NUM1 - $NUM2 = $[ $NUM1 - $NUM2 ]"
    elif [ "$opc" = multiplicacao ]; then
	Mecho "$NUM1 * $NUM2 = $[ $NUM1 * $NUM2 ]"
    elif [ "$opc" = divisao ]; then
	Mecho "$NUM1 / $NUM2 = `echo "scale=2;$NUM1/$NUM2" | bc -l`"
    elif [ "$opc" = sair ]; then
	Mecho "Tchau! "
	exit
    else
	Mecho "Opção inválida! "
    fi
done

<-->
/* ----------------- */

   Bem prático, não acha? ;-)



7.3. dialog
     ======

   AVISO: o dialog não um comando específico do bash! Estou escrevendo
sobre ele porque já vi muita gente querendo informações sobre ele e
porque eu particularmente acho ele uma fofura. :-)

   O dialog serve para fazer caixas de diálogo, e a sintaxe básica é
assim:

   dialog [ opcoes de título ] opções da caixa

   As opções de título são opcionais (por isso que elas estão entre
colchetes. duh!), as de caixa são obrigatórias. Para que você possa fazer
agora uma apreciação visual do dialog tente o seguinte comando:

dialog --yesno "Caixa onde se se escolhe Yes ou No" 0 0

   Existem vários tipos de caixas, a utilizada nesse comando é uma caixa
do tipo "yesno". Bem... isso foi só pra você dar uma admirada rápida no
dialog. Agora vamos organizar as coisas, vou explicar alguns parâmetros.
Vá praticando cada um desses parâmetros e vendo o resultado. Lembre-se que
as opções da caixa são obrigatórias!


* --backtitle "texto"

   Este parâmetro é para por um título "lá atrás". Tente 
dialog --backtitle "Micro\$oft Scandisk" --yesno bla 0 0
e veja como o título que aparece lhe trará péssimas lembranças. =)

   
* --title "texto"

   Este vai ser o título da caixa de diálogo.


   Agora vamos as opções de caixa, mas antes uma informação:
Em todos os tipos de caixas existem os argumentos "altura" e "largura"
(que para abreviar, eu chamarei de "alt" e "larg"), que (por incrível
que pareça) servem para você determinar a altura e largura da caixa de
diálogo. Se você não tiver saco pra ficar contando quantos caracteres
serão usados na caixa, use 0 para altura e largura, assim a caixa terá um
tamanho de acordo com texto utilizado.


* --yesno "texto" alt larg

   Faz uma caixa de diálogo com as opções "Yes" e "No". Se você escolher
"Yes" o dialog retorna 0, caso contrário, retorna 1.


* --msgbox "texto" alt larg

   Serve para mostrar uma mensagem e tem um botão de confirmação "OK".
Quando você escolher "OK" o dialog retornará 0, e, assim como em todos os
outros tipos de caixas, você pode cancelar via tecla ESC, quando o dialog
retornará 255.


* --inputbox "texto" alt larg [string de inicio]

   Faz uma caixa de entrada de dados, se "string de inicio" for passada o
campo de entrada de dados será inicializado por esta string. Os botões
são "OK" E "Cancel", o primeiro, se selecionado, retorna 0 e o outro
retorna 1. A string que você entrar será direcionada para a saída de erro
padrão, portanto, se você quer que isto seja gravado use redirecionamento
de stderr (ver 3.3 Redirecionamento).


* --textbox arquivo alt larg

   É como se fosse um simples visualizador de arquivos texto. Use as
setinhas do teclado para se movimentar. Para pesquisar pra frente use '/'
e para pesquisar pra trás use '?'.


* --menu "texto" alt larg alt-do-menu item1 "descricao do item1" \
                                    [ itemN "descricao do itemN" ]

   Note que aquela '\' lá no final da linha significa que o comando
continua na próxima linha. Como o próprio nome diz, esse parâmetro é
usado para fazer menus, como por exemplo aquele do pppsetup (slackware)
onde você escolhe qual o ttyS do seu modem. O item que for escolhido será
impresso em stderr. "OK" retorna 0 e "Cancel" retorna 1.
   Veja um exemplo besta só pra ilustrar:

/* ----------------- */
<++> BashScript/menudialogtest.sh
#!/bin/bash

FILE=/tmp/script-$$

dialog --title "Teste fuleiro da caixa de diálogo \"menu\"" \
  --menu "Qual comando você deseja executar?" 0 0 0 \
  "pwd" "mostra o diretório atual" \
  "ps aux" "lista os processos que estão sendo executados" \
  "uname -a" "exibe informações sobre o SO e a máquina local" \
  "users" "lista os usuários que estão logados no momento" 2> $FILE

# Lembre-se que o item escolhido será impresso em stderr. E repare
# acima que eu estou redirecionando stderr para um arquivo.

RET_VAL=$?
[ $RET_VAL -eq 0 ] || { echo "Operação cancelada."; exit 1; }

sh $FILE

rm $FILE
<-->
/* ----------------- */


* --checklist "texto" alt larg alt-da-lista \
   item1 "descricao do item1" status [ item2 "descricao do item2" status ]

   Note novamente o caractere '\' fazendo o comando continuar na linha
abaixo. Este tipo de caixa é utilizado quando se quer fazer um menu onde
pode-se escolher vários itens, você marca os que deseja e dá "OK". Assim
como o "--menu", o(s) item(ns) que for(em) escolhido(s) serão impressos em
stderr. O parâmetro "status" serve para você deixar um determinado item
selecionado logo de início, seus valores podem ser "on" ou "off".
   Veja este exemplo bem interessante (oh! finalmente um exemplo com
alguma utilidade!) que usa muitos dos conceitos já ensinados até aqui, se
não entender releia o código:

/* ----------------- */
<++> BashScript/bacanas/mp3select.sh
#!/bin/bash
#
#   "Escolhedor" de mp3z feito para ilustrar o uso do 'dialog'
# no texto "Programação em Bourne-Again Shell".
#
#   Para utilizar este script é necessário ter instalado o mpg123.
#
# + OBS.: Se o nome de alguma mp3 for muito grande podem acontecer
# resultados bizarros... :-/
# + OBS.II: Este script não "detecta" nome de mp3z que contenham
# espaços. Pois se detectasse também ocorreriam resultados bizarros.
#
# Feito por: meleu <meleu@meleu.cjb.net>


# mude a variável MP3DIR e descomente-a para não
# precisar passar o diretório toda hora na linha
# de comando.
#MP3DIR="$HOME/mp3z/"
FILE="/tmp/mp3.$$"
NCOR="\e[m"
WHITE="\e[1m"


function AjudarSair {
	echo "Tente \"`basename $0` -h\" para ajuda."
	exit $1
}


function ApagarSair {
	rm $FILE
	exit $1
}


# óia o getopts aê gente! =)
while getopts 'd:n:h' OPCAO; do
    case $OPCAO in
    d) MP3DIR="$OPTARG" ;;
    n) NOME="*$OPTARG" ;;
    h) echo -e "
${WHITE}* Meleu's mp3 escolheitor (Tabajara, Inc.)$NCOR

Uso: `basename $0` [-d diretorio] [-n nome] [-h]

-d diretorio	diretório onde serão procuradas as mp3z
-n nome		nome que será procurado no diretório
-h		imprime esta mensagem
"
       exit ;;
    *) exit 1 ;;
    esac
done


if [ -z "$MP3DIR" ]; then
  echo -e "${WHITE}Você precisa indicar em qual diretório estão as mp3z.$NCOR"
  AjudarSair 1
elif [ ! -d "$MP3DIR" ]; then
  echo -e "$WHITE\"$MP3DIR\" não é um diretório.$NCOR"
  AjudarSair 1
fi

cd "$MP3DIR"

LISTA=`/bin/ls -1 $NOME*.mp3 2>/dev/null | grep -v ' '`
[ -z "$LISTA" ] && {
	echo -e "${WHITE}Nenhuma mp3 foi encontrada em \"$MP3DIR\".$NCOR"
	AjudarSair 1
}

CONT=1

dialog --backtitle "Selecionador de mp3z" \
 --title "$MP3DIR" \
 --checklist "Escolha a música" 0 0 0 \
$(for ITEM in $LISTA ; do
	echo "$ITEM" "$CONT" off
	(( CONT++ ))
done) 2>> $FILE

RET_VAL=$?
[ $RET_VAL -ne 0 ] && { echo "Tchau!"; ApagarSair; }


# verificando se já existe um processo com o mpg123
MPGPID=`ps ax --format pid,comm | grep mpg123 | cut -c-6`
[ $MPGPID ] && {
	dialog --backtitle "Selecionador de mp3z" \
	--title "O mpg123 JÁ ESTÁ SENDO USADO!" \
	--yesno "Deseja finalizá-lo para ouvir a sua lista?" 0 0
	RET_VAL=$?
	if [ $RET_VAL -eq 0 ]; then
	    kill $MPGPID 2>/dev/null || {
		echo -e "${WHITE}Não foi possível finalizar o mpg123.$NCOR"
		echo "Pode ser que outro usuário esteja utilizando-o."
		ApagarSair 1
	    }
	else
	    echo "Saindo..."
	    ApagarSair
	fi
}

# o sleep é pra garantir que o /dev/dsp estará desocupado
sleep 1s

cat $FILE | xargs mpg123 2> /dev/null &

ApagarSair

# EoF #
<-->
/* ----------------- */


* --radiolist "texto" alt larg alt-da-lista \
    item1 "descricao do item1" status [ item2 "descricao do item2 status ]

   Similar ao --checklist porém aqui só se pode fazer uma escolha, quando
você seleciona um item desmarca outro. Faça os testes por sua conta.



   Chega de moleza! Se quiser saber mais leia a man page do dialog! ;)

